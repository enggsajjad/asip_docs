// Copyright (C) 2011 ASIP Solutions, Inc. All rights reserved. 
// Generated by ASIP Meister 2.3 on 2019/01/30 15:35:58 
mod "browstd32PO"
{
/* Architecture Parameter */
  num_stages 4;
  stage IF : fetch_stage;
  stage ID : decode_stage;
  stage EXE : exec_stage;
  stage WB : memory_read_stage,memory_write_stage;

/* Resource */
  resource PC : program_counter
  {
    model "pcu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 increment_step=4 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 increment_step=4 adder_algorithm=default";
    };
  };
  resource IR : instr_register
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource IMAU : instr_memory
  {
    model "mifu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 address_space=32 access_width=32 access_mode=single_cycle type=read_only";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 address_space=32 access_width=32 access_mode=single_cycle type=read_only";
    };
  };
  resource DMAU : data_memory
  {
    model "mifu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 address_space=32 access_width=8 access_mode=multi_cycle type=read_write";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 address_space=32 access_width=8 access_mode=multi_cycle type=read_write";
    };
  };
  resource ALU
  {
    model "alu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=default";
    };
  };
  resource MUL
  {
    model "multiplier";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 algorithm=seq data_type=two_complement";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=seq adder_algorithm=default data_type=two_complement";
    };
  };
  resource DIV
  {
    model "divider";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 algorithm=seq data_type=two_complement";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=seq adder_algorithm=default data_type=two_complement";
    };
  };
  resource EXT8TO32
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=8 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=8 bit_width_out=32";
    };
  };
  resource EXT16TO32
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=16 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=16 bit_width_out=32";
    };
  };
  resource EXT26TO32
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=26 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=26 bit_width_out=32";
    };
  };
  resource SFTvar
  {
    model "shifter";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 amount=variable";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 amount=variable";
    };
  };
  resource EXTINT
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource EXTCATCH_OUT
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1 default_output=fix_to_0";
    };
  };
  resource TRAP_HAND_REG
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource FWU0
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
  };
  resource FWU1
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
  };
  resource DUMMY_STREG : mask_register
  {
    model "dummy_register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource GPR : register_file
  {
    model "browregfile";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 num_register=32 num_read_port=4 num_write_port=1 num_bank=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 num_register=32 num_read_port=4 num_write_port=1 num_bank=1";
    };
  };
  resource EXT16TO32A
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=16 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=16 bit_width_out=32";
    };
  };
  resource newADDER1
  {
    model "adder";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=default";
    };
  };
  resource newADDER2
  {
    model "adder";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=default";
    };
  };
  resource FWU2
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
  };

/* Instruction Type */
  instr_type RR
  {
    operand [31:27] rs1;
    operand [26:22] rs2;
    operand [21:17] rd;
    opecode [16:14] f_type;
    opecode [13:6] func;
    opecode [5:0] bin000="000001";
  };
  instr_type RI
  {
    operand [31:16] const;
    operand [15:11] rs1;
    operand [10:6] rd;
    opecode [5:0] op;
  };
  instr_type MA_ST
  {
    operand [31:16] const;
    operand [15:11] rs1;
    operand [10:6] rd;
    opecode [5:0] op;
  };
  instr_type MA_LD
  {
    operand [31:16] const;
    operand [15:11] rs1;
    operand [10:6] rd;
    opecode [5:0] op;
  };
  instr_type BR
  {
    operand [31:16] const;
    operand [15:11] rs1;
    dont_care [10:6] unused;
    opecode [5:0] op;
  };
  instr_type JP
  {
    operand [31:6] const;
    opecode [5:0] op;
  };
  instr_type JPR
  {
    dont_care [31:11] unused;
    operand [10:6] rs1;
    opecode [5:0] op;
  };
  instr_type SP
  {
    dont_care [31:11] unused;
    opecode [10:6] func;
    opecode [5:0] bin000="000000";
  };
  instr_type RT
  {
    operand [31:27] rd;
    operand [26:22] rs1;
    opecode [21:11] func;
    opecode [10:6] bin000="00010";
    opecode [5:0] bin001="000000";
  };
  instr_type RR2
  {
    operand [31:27] rd;
    operand [26:22] rs1;
    opecode [21:0] op;
  };
  instr_type RR3
  {
    operand [31:27] rs1;
    operand [26:22] rs2;
    operand [21:17] rs3;
    operand [16:12] rd;
    opecode [11:6] func;
    opecode [5:0] ope;
  };

/* I/O Port */
  top_module BrownieSTD32;
  clock_port CLK;
  reset_port RESET;
  port [31:0] IMEM_ADDR_OUT {
    direction out;
    connect_to IMAU.addr2mem;
  };
  port [31:0] IMEM_DATA_IN {
    direction in;
    connect_to IMAU.data2cpu;
  };
  port IMEM_ADDRERR_IN {
    direction in;
    connect_to IMAU.aderr2cpu;
  };
  port [31:0] DMEM_ADDR_OUT {
    direction out;
    connect_to DMAU.addr2mem;
  };
  port [31:0] DMEM_DATA_IN {
    direction in;
    connect_to DMAU.data2cpu;
  };
  port [31:0] DMEM_DATA_OUT {
    direction out;
    connect_to DMAU.data2mem;
  };
  port DMEM_REQ_OUT {
    direction out;
    connect_to DMAU.req2mem;
  };
  port DMEM_ACK_IN {
    direction in;
    connect_to DMAU.ack2cpu;
  };
  port DMEM_RW_OUT {
    direction out;
    connect_to DMAU.rw2mem;
  };
  port [1:0] DMEM_WMODE_OUT {
    direction out;
    connect_to DMAU.mode2mem;
  };
  port DMEM_EMODE_OUT {
    direction out;
    connect_to DMAU.ext2mem;
  };
  port DMEM_ADDRERR_IN {
    direction in;
    connect_to DMAU.aderr2cpu;
  };
  port DMEM_CANCEL_OUT {
    direction out;
    connect_to DMAU.cancel2mem;
  };
  port EXTINT_IN {
    direction in;
    connect_to internal_controller;
  };
  port EXTCATCH_OUT {
    direction out;
    connect_to EXTCATCH_OUT.ext_port;
  };

/* Exception */
  reset_interrupt RESET {
    cause_condition {
      port RESET;
      active_value '1';
    };
  };
  external_interrupt EXTINT {
    cause_condition {
      port EXTINT_IN;
      active_value '1';
    };
    mask_condition {
      mask_register DUMMY_STREG;
      mask_bitpos 8;
      active_value '0';
    };
  };
  internal_interrupt TRAPINT {
    cause_condition_type instr_specific;
    mask_condition {
      mask_register DUMMY_STREG;
      mask_bitpos 9;
      active_value '0';
    };
  };

  catch_interrupt EXTINT {
    wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire        one;

    ret_addr     = saved_pc;                           // Get saved pc
    //handler_addr = "00001111111111100000010000000000"; // 0x0FFE0400 (fixed)
    //handler_addr = "00000000000000000011010000000000"; // 0x0FFE0400 (fixed)
    handler_addr = "00000000000000001111010000000000"; // 0x0000F400 (fixed)
    mask         = "11111111111111111011110011111111"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
    rsave        = "00010";                            // R2 (Interrupt Return)
    rstatus      = "00001";                            // R1 (Status Register)
    one          = '1';
    
    current_st   = DUMMY_STREG.read();                 // load current status
    new_st       = current_st & mask;                  // masking interrupts
    
    null = EXTCATCH_OUT.write(one);                    // output catch signal for 1 cycle
    null = GPR.write0(rsave, ret_addr);                // write return address
    null = GPR.status_write(new_st);                   // write masked status
    null = PC.write(handler_addr);                     // jump to the handler
  };
  catch_interrupt RESET {
    wire [31:0] reset_handler;

    // set the pc 0x0FFE0000
    //reset_handler = "00001111111111100000000000000000";
    //reset_handler = "00000000000000000011000000000000";
    reset_handler = "00000000000000001111000000000000"; // 0x0000F000 (fixed)
    null = PC.write(reset_handler);
    
    // reset all memories
    null = GPR.reset();
    null = IR.reset();
    null = DIV.reset();
    null = MUL.reset();
    null = TRAP_HAND_REG.reset();
  };
  catch_interrupt TRAPINT {
    wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire [31:0] trap_factor;
wire [31:0] trap_base;
wire [3:0]  trap_alu_flag;

    ret_addr     = saved_pc;                           // Get saved pc
    //trap_base    = "00001111111111100000100000000000"; // 0x0FFE0800 (fixed)
    //trap_base    = "00000000000000000011100000000000"; // 0x0FFE0800 (fixed)
    trap_base    = "00000000000000001111100000000000"; // 0x0000F800 (fixed)
    mask         = "11111111111111111011110011111111"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
    rsave        = "00010";                            // R2 (Interrupt Return)
    rstatus      = "00001";                            // R1 (Status Register)
    
    current_st   = DUMMY_STREG.read();                 // load current status
    new_st       = current_st & mask;                  // masking interrupts
    
    trap_factor  = TRAP_HAND_REG.read();               // get trap factor
    <handler_addr, trap_alu_flag>
                 = ALU.add(trap_base, trap_factor);    // calculate dest. addr.
    
    
    null = GPR.write0(rsave, ret_addr);                // write return address
    null = GPR.status_write(new_st);                   // write masked status
    null = PC.write(handler_addr);                     // jump to the handler
  };

/* Instruction */
  instruction ADD : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction SUB : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[sub] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.sub(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction MUL : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  mul_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [63:0]  mul_exec_tmp_result;
      
      // multiplier execution
      mul_exec_tmp_result = MUL.mul(source1, source2);
      mul_result          = mul_exec_tmp_result[31:0];
      // foward mul_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, mul_result);
      null = FWU1.forward1(rd, mul_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, mul_result);        // write mul_result[arg2] to GPR[arg1]
      // foward mul_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, mul_result);
      null = FWU1.forward2(rd, mul_result);
    };
  };
  instruction DIV : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.div(source1, source2);
      // foward div_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, div_result);
      null = FWU1.forward1(rd, div_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, div_result);        // write div_result[arg2] to GPR[arg1]
      // foward div_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, div_result);
      null = FWU1.forward2(rd, div_result);
    };
  };
  instruction DIVU : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.divu(source1, source2);
      // foward div_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, div_result);
      null = FWU1.forward1(rd, div_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, div_result);        // write div_result[arg2] to GPR[arg1]
      // foward div_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, div_result);
      null = FWU1.forward2(rd, div_result);
    };
  };
  instruction MOD : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.div(source1, source2);
      // foward mod_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, mod_result);
      null = FWU1.forward1(rd, mod_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, mod_result);        // write mod_result[arg2] to GPR[arg1]
      // foward mod_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, mod_result);
      null = FWU1.forward2(rd, mod_result);
    };
  };
  instruction MODU : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.divu(source1, source2);
      // foward mod_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, mod_result);
      null = FWU1.forward1(rd, mod_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, mod_result);        // write mod_result[arg2] to GPR[arg1]
      // foward mod_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, mod_result);
      null = FWU1.forward2(rd, mod_result);
    };
  };
  instruction AND : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[and] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.and(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction NAND : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[nand] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.nand(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction OR : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[or] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.or(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction NOR : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[nor] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.nor(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction XOR : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[xor] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.xor(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction LLS : RR
  {
    opecode  f_type = "010";
    opecode  func = "00000000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
      sft_amt = source2[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sll(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction LRS : RR
  {
    opecode  f_type = "010";
    opecode  func = "00000001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
      sft_amt = source2[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.srl(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction ARS : RR
  {
    opecode  f_type = "010";
    opecode  func = "00000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
      sft_amt = source2[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sra(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction ELT : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000000";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_lt>;                    // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction ELTU : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000001";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_ult>;                   // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction EEQ : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000010";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_equal>;                 // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction ENEQ : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000011";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_nequal>;                // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction ADDI : RI
  {
    opecode  op = "100000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction SUBI : RI
  {
    opecode  op = "100001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[sub] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.sub(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction ANDI : RI
  {
    opecode  op = "100010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[and] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.and(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction ORI : RI
  {
    opecode  op = "100011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[or] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.or(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction XORI : RI
  {
    opecode  op = "100100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[xor] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.xor(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction LLSI : RI
  {
    opecode  op = "100101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
      sft_amt = const[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sll(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction LRSI : RI
  {
    opecode  op = "100110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
      sft_amt = const[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.srl(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction ARSI : RI
  {
    opecode  op = "100111";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
      sft_amt = const[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sra(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction LSOI : RI
  {
    opecode  op = "101000";

    wire [31:0] shifted_source1;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [15:0] lower_bits;
      wire [15:0] zeros;
      // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
      // shift source data before OR
      lower_bits      = source1[15:0];
      zeros           = "0000000000000000";
      shifted_source1 = <lower_bits, zeros>;
    };

    stage 3 :
    {
      // execute operation[or] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.or(shifted_source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction LB : MA_LD
  {
    opecode  op = "000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag;
    wire [31:0] load_result; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
    };

    stage 4 :
    {
      wire        load_alu_result_err;
      
      // result is 32bit data. already extended
      <load_result, load_alu_result_err> = DMAU.ld_8(alu_result);
      null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
      // foward load_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, load_result);
      null = FWU1.forward2(rd, load_result);
    };
  };
  instruction LH : MA_LD
  {
    opecode  op = "000011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag;
    wire [31:0] load_result; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
    };

    stage 4 :
    {
      wire        load_alu_result_err;
      
      // result is 32bit data. already extended
      <load_result, load_alu_result_err> = DMAU.ld_16(alu_result);
      null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
      // foward load_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, load_result);
      null = FWU1.forward2(rd, load_result);
    };
  };
  instruction LW : MA_LD
  {
    opecode  op = "000100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag;
    wire [31:0] load_result; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
    };

    stage 4 :
    {
      wire        load_alu_result_err;
      
      // result is 32bit data. already extended
      <load_result, load_alu_result_err> = DMAU.ld_32(alu_result);
      null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
      // foward load_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, load_result);
      null = FWU1.forward2(rd, load_result);
    };
  };
  instruction SB : MA_ST
  {
    opecode  op = "000101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  source3;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_ext16to32_stmp1;
      wire [31:0]  gpr_double_read_ext16to32_stmp2;
      wire [31:0]  gpr_double_read_ext16to32_stmp3;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      // and also, STATUS_REG data to stmp3
      gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
      gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
      gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
      source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
      source3 = gpr_double_read_ext16to32_stmp3;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source3);
    };

    stage 4 :
    {
      wire         store_alu_result_err;
      
      // result is 32bit source2. already extended
      store_alu_result_err = DMAU.s_8(alu_result, source2);
    };
  };
  instruction SH : MA_ST
  {
    opecode  op = "000110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  source3;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_ext16to32_stmp1;
      wire [31:0]  gpr_double_read_ext16to32_stmp2;
      wire [31:0]  gpr_double_read_ext16to32_stmp3;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      // and also, STATUS_REG data to stmp3
      gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
      gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
      gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
      source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
      source3 = gpr_double_read_ext16to32_stmp3;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source3);
    };

    stage 4 :
    {
      wire         store_alu_result_err;
      
      // result is 32bit source2. already extended
      store_alu_result_err = DMAU.s_16(alu_result, source2);
    };
  };
  instruction SW : MA_ST
  {
    opecode  op = "000111";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  source3;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_ext16to32_stmp1;
      wire [31:0]  gpr_double_read_ext16to32_stmp2;
      wire [31:0]  gpr_double_read_ext16to32_stmp3;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      // and also, STATUS_REG data to stmp3
      gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
      gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
      gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
      source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
      source3 = gpr_double_read_ext16to32_stmp3;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source3);
    };

    stage 4 :
    {
      wire         store_alu_result_err;
      
      // result is 32bit source2. already extended
      store_alu_result_err = DMAU.s_32(alu_result, source2);
    };
  };
  instruction BRZ : BR
  {
    opecode  op = "001001";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0]  source1;
    wire [31:0]  source2; wire [15:0] const; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; pcread_result = PC.read();
      // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [31:0] relative_branchz_abs_addr;
      wire [3:0]  relative_branchz_alu_flag;
      wire        relative_branchz_cond;
      
      // evaluate source1 equal or not equal to zero
      relative_branchz_cond = source1 == "00000000000000000000000000000000";
      
      // branch according to the cond
      <relative_branchz_abs_addr, relative_branchz_alu_flag> 
                           = ALU.add(pcread_result, source2);  // calu. absolute address
      null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch
    };

    stage 4 :
    {
      
    };
  };
  instruction BRNZ : BR
  {
    opecode  op = "001010";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0]  source1;
    wire [31:0]  source2; wire [15:0] const; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; pcread_result = PC.read();
      // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [31:0] relative_branchz_abs_addr;
      wire [3:0]  relative_branchz_alu_flag;
      wire        relative_branchz_cond;
      
      // evaluate source1 equal or not equal to zero
      relative_branchz_cond = source1 != "00000000000000000000000000000000";
      
      // branch according to the cond
      <relative_branchz_abs_addr, relative_branchz_alu_flag> 
                           = ALU.add(pcread_result, source2);  // calu. absolute address
      null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch
    };

    stage 4 :
    {
      
    };
  };
  instruction JP : JP
  {
    opecode  op = "001011";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0] ext26to32_result; wire [25:0] const;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); const = tmp_ir[31:6]; pcread_result = PC.read();
      ext26to32_result = EXT26TO32.sign(const);
    };

    stage 3 :
    {
      wire [31:0] relative_jump_abs_addr;
      wire [3:0]  relative_jump_alu_flag;
      
      <relative_jump_abs_addr, relative_jump_alu_flag> 
                           = ALU.add(pcread_result, ext26to32_result);         // calu. absolute address
      null                 = PC.write(relative_jump_abs_addr); // jump
    };

    stage 4 :
    {
      
    };
  };
  instruction JPL : JP
  {
    opecode  op = "001100";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0] ext26to32_result; wire [25:0] const;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); const = tmp_ir[31:6]; pcread_result = PC.read();
      ext26to32_result = EXT26TO32.sign(const);
    };

    stage 3 :
    {
      wire [4:0] linkreg_idx;
      wire [31:0] relative_jump_abs_addr;
      wire [3:0]  relative_jump_alu_flag;
      
      linkreg_idx = "00011";
      <relative_jump_abs_addr, relative_jump_alu_flag> 
                           = ALU.add(pcread_result, ext26to32_result);         // calu. absolute address
      null                 = PC.write(relative_jump_abs_addr); // jump
      // foward pcread_result to as GPR[linkreg_idx] from stage EXE
      null = FWU0.forward1(linkreg_idx, pcread_result);
      null = FWU1.forward1(linkreg_idx, pcread_result);
    };

    stage 4 :
    {
      wire [4:0] linkreg_idx;
      
      linkreg_idx = "00011";
      null = GPR.write0(linkreg_idx, pcread_result);        // write pcread_result[arg2] to GPR[arg1]
      // foward pcread_result to as GPR[linkreg_idx] from stage WB
      null = FWU0.forward2(linkreg_idx, pcread_result);
      null = FWU1.forward2(linkreg_idx, pcread_result);
    };
  };
  instruction TRAP : JP
  {
    opecode  op = "001101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] ext26to32_result; wire [25:0] const;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); const = tmp_ir[31:6]; ext26to32_result = EXT26TO32.zero(const);
      // store handler address
      // this address will be used in TRAP_INT
      null = TRAP_HAND_REG.write(ext26to32_result);
    };

    stage 3 :
    {
      // throw exception
      throw TRAPINT;
    };

    stage 4 :
    {
      
    };
  };
  instruction JPR : JPR
  {
    opecode  op = "001110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      null = PC.write(source1); // jump according to absolute address
    };

    stage 4 :
    {
      
    };
  };
  instruction JPRL : JPR
  {
    opecode  op = "001111";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0] source1; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[10:6]; pcread_result = PC.read();
      // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      wire [4:0] linkreg_idx;
      
      linkreg_idx = "00011";
      null = PC.write(source1); // jump according to absolute address
      // foward pcread_result to as GPR[linkreg_idx] from stage EXE
      null = FWU0.forward1(linkreg_idx, pcread_result);
      null = FWU1.forward1(linkreg_idx, pcread_result);
    };

    stage 4 :
    {
      wire [4:0] linkreg_idx;
      
      linkreg_idx = "00011";
      null = GPR.write0(linkreg_idx, pcread_result);        // write pcread_result[arg2] to GPR[arg1]
      // foward pcread_result to as GPR[linkreg_idx] from stage WB
      null = FWU0.forward2(linkreg_idx, pcread_result);
      null = FWU1.forward2(linkreg_idx, pcread_result);
    };
  };
  instruction NOP : SP
  {
    opecode  func = "00000";

    /* these variables can be used in following stages of all instructions */

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); 
    };

    stage 3 :
    {
      
    };

    stage 4 :
    {
      
    };
  };
  instruction RETI : SP
  {
    opecode  func = "00001";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] streg_read_result;
    wire [31:0] source1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [4:0] ret_idx;
      wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); ret_idx = "00010";                // interrupt return address is stored in GPR2
      // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(ret_idx);
      source1        = FWU0.forward(ret_idx, gpr_read_stmp1);
      // get return address
      streg_read_result = DUMMY_STREG.read();
    };

    stage 3 :
    {
      wire [31:0] new_st;
      wire [31:0] mask;
      
      mask         = "00000000000000000100001100000000"; // clear interrupt mask and move to user mode
      new_st       = streg_read_result | mask;           // 
      null         = GPR.status_write(new_st);           // update status register (interrupt will be enabled at next cycle)
      null = PC.write(source1); // jump according to absolute address
    };

    stage 4 :
    {
      
    };
  };
  instruction EXBW : RT
  {
    opecode  func = "00000000000";

    wire [31:0] extended_data;
    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1; wire [4:0] rd; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rd = tmp_ir[31:27]; rs1 = tmp_ir[26:22]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      wire [7:0] target;
      
      target        = source1[7:0];
      extended_data = EXT8TO32.sign(target);
      // foward extended_data to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, extended_data);
      null = FWU1.forward1(rd, extended_data);
    };

    stage 4 :
    {
      null = GPR.write0(rd, extended_data);        // write extended_data[arg2] to GPR[arg1]
      // foward extended_data to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, extended_data);
      null = FWU1.forward2(rd, extended_data);
    };
  };
  instruction EXHW : RT
  {
    opecode  func = "00000000001";

    wire [31:0] extended_data;
    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1; wire [4:0] rd; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rd = tmp_ir[31:27]; rs1 = tmp_ir[26:22]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      wire [15:0] target;
      
      target        = source1[15:0];
      extended_data = EXT16TO32A.sign(target);
      // foward extended_data to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, extended_data);
      null = FWU1.forward1(rd, extended_data);
    };

    stage 4 :
    {
      null = GPR.write0(rd, extended_data);        // write extended_data[arg2] to GPR[arg1]
      // foward extended_data to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, extended_data);
      null = FWU1.forward2(rd, extended_data);
    };
  };
  instruction STEP2 : RR2
  {
    opecode  op = "0000011100000000110001";

    wire check_negative;
    wire [31:0] resultO;
    wire [31:0] output;
    wire [31:0] ZERO;
    wire [31:0] yes88;
    wire zero;
    wire one;
    wire ge88;
    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rd; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rd = tmp_ir[31:27]; rs1 = tmp_ir[26:22]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      zero = '0';
      one = '1';
      ZERO = "00000000000000000000000000000000";
      yes88 = "00000000000000000000000001011000";
      
      check_negative = source1[31]; 
      
      
      
      
      
      
      
      
      
      
      //twos complement, 32nd bit = 1 if negative
      //resultN = (check_negative) ? ZERO : source1;
      alu_cmp_alu_flag = ALU.cmp(source1, yes88);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      ge88 = (cmp_lt) ? zero : one;
      resultO = (ge88) ? yes88 : source1;
      output = (check_negative) ? ZERO : resultO;
      // foward output to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, output);
      null = FWU1.forward1(rd, output);
    };

    stage 4 :
    {
      null = GPR.write0(rd, output);        // write output[arg2] to GPR[arg1]
      // foward output to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, output);
      null = FWU1.forward2(rd, output);
    };
  };
  instruction STEP5 : RR2
  {
    opecode  op = "0000011100000000110010";

    wire bit0;
    wire bit1;
    wire bit2;
    wire bit3;
    wire bit4;
    wire bit5;
    wire bit6;
    wire bit7;
    wire bit8;
    wire bit9;
    wire bit10;
    wire bit11;
    wire bit12;
    wire bit13;
    wire bit14;
    wire bit15;
    wire bit16;
    
    
    wire aux2;
    wire aux3;
    wire aux4;
    wire aux5;
    wire aux6;
    wire aux7;
    wire aux8;
    wire aux9;
    wire aux10;
    wire aux11;
    wire aux12;
    wire aux13;
    wire aux14;
    wire aux15;
    wire aux16;
    
    
    wire n_aux2;
    wire n_aux3;
    wire n_aux4;
    wire n_aux5;
    wire n_aux6;
    wire n_aux7;
    wire n_aux8;
    wire n_aux9;
    wire n_aux10;
    wire n_aux11;
    wire n_aux12;
    wire n_aux13;
    wire n_aux14;
    wire n_aux15;
    wire n_aux16;
    
    wire zero;
    wire one;
    wire [31:0] DOWNLIMIT;
    wire [31:0] UPLIMIT;
    wire [31:0] outputO;
    wire [31:0] output;
    wire check_negative;
    wire check_overflow;
    wire check_underflow;
    wire inversed_check_negative;
    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1; wire [4:0] rd; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rd = tmp_ir[31:27]; rs1 = tmp_ir[26:22]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      zero = '0';
      one = '1';
         DOWNLIMIT = "11111111111111111000000000000000";
           UPLIMIT = "00000000000000000111111111111111";
      
      
      //ON BOTH LIMITS I NEED TO COMPARE THE BIG PART 
      
      
      check_negative = source1[31];
      inversed_check_negative = (check_negative) ? zero : one;
      bit0 = source1[31];
      bit1 = source1[30];
      bit2 = source1[29];
      bit3 = source1[28];
      bit4 = source1[27];
      bit5 = source1[26];
      bit6 = source1[25];
      bit7 = source1[24];
      bit8 = source1[23];
      bit9 = source1[22];
      bit10 = source1[21];
      bit11 = source1[20];
      bit12 = source1[19];
      bit13 = source1[18];
      bit14 = source1[17];
      bit15 = source1[16];
      bit16 = source1[15];
      
      
      
      
      
      
      
      
      
      //HERE I CHECK IF IT HAS A 1 IN ANY POSITION
      //aux1 = bit0 | bit1; 
      
      //WE SHOULDNT CHECK THE SIGN BIT
      aux2 = bit1 | bit2;
      aux3 = aux2 | bit3;
      aux4 = aux3 | bit4;
      aux5 = aux4 | bit5;
      aux6 = aux5 | bit6;
      aux7 = aux6 | bit7;
      aux8 = aux7 | bit8;
      aux9 = aux8 | bit9;
      aux10 = aux9 | bit10;
      aux11 = aux10 | bit11;
      aux12 = aux11 | bit12;
      aux13 = aux12 | bit13;
      aux14 = aux13 | bit14;
      aux15 = aux14 | bit15;
      aux16 = aux15 | bit16;
      
      check_overflow = aux16 & inversed_check_negative; //IF THERE IS A 1 AND ITS NOT A NEGATIVE NUMBER THEN OVERFLOW
      outputO = (check_overflow) ? UPLIMIT : source1;
      
      
      
      
      
      
      
      
      
      //HERE I CHECK IF IT HAS A 0 IN ANY POSITION
      //n_aux1 = bit0 & bit1; 
      
      //WE SHOULDNT CHECK THE SIGN BIT
      n_aux2 = bit1 & bit2;
      n_aux3 = n_aux2 & bit3;
      n_aux4 = n_aux3 & bit4;
      n_aux5 = n_aux4 & bit5;
      n_aux6 = n_aux5 & bit6;
      n_aux7 = n_aux6 & bit7;
      n_aux8 = n_aux7 & bit8;
      n_aux9 = n_aux8 & bit9;
      n_aux10 = n_aux9 & bit10;
      n_aux11 = n_aux10 & bit11;
      n_aux12 = n_aux11 & bit12;
      n_aux13 = n_aux12 & bit13;
      n_aux14 = n_aux13 & bit14;
      n_aux15 = n_aux14 & bit15;
      n_aux16 = n_aux15 & bit16;
      
      
      check_underflow = n_aux16 & check_negative; //IF THERE IS A 0 AND ITS A NEGATIVE NUMBER THEN UNDERFLOW
      output = (check_underflow) ? DOWNLIMIT : outputO;
      // foward output to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, output);
      null = FWU1.forward1(rd, output);
    };

    stage 4 :
    {
      null = GPR.write0(rd, output);        // write output[arg2] to GPR[arg1]
      // foward output to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, output);
      null = FWU1.forward2(rd, output);
    };
  };
  instruction STEP4a : RR
  {
    opecode  f_type = "111";
    opecode  func = "10000001";

    wire [31:0] output;
    wire [31:0] initial_value;
    
    wire [31:0] shifted0;
    wire [31:0] shifted1;
    wire [31:0] shifted2;
    wire [31:0] shifted3;
    
    wire check4;
    wire check2;
    wire check1;
    
    wire [31:0] checkedvalue1;
    wire [31:0] checkedvalue2;
    wire [31:0] checkedvalue4;
    wire [31:0] ZERO;
    
    wire s1bit0;
    wire s1bit1;
    wire s1bit2;
    wire s1bit3;
    wire s1bit4;
    wire s1bit5;
    wire s1bit6;
    wire s1bit7;
    wire s1bit8;
    wire s1bit9;
    wire s1bit10;
    wire s1bit11;
    wire s1bit12;
    wire s1bit13;
    wire s1bit14;
    wire s1bit15;
    wire s1bit16;
    wire s1bit17;
    wire s1bit18;
    wire s1bit19;
    wire s1bit20;
    wire s1bit21;
    wire s1bit22;
    wire s1bit23;
    wire s1bit24;
    wire s1bit25;
    wire s1bit26;
    wire s1bit27;
    wire s1bit28;
    wire s1bit29;
    wire s1bit30;
    wire s1bit31;
    wire zero;
    wire one;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag;
    wire [31:0] triple_adder_output1;
    wire triple_adder_cout1;
    wire triple_adder_cout2;
    wire [31:0] triple_adder_output;
    wire triple_adder_zero; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      ZERO = "00000000000000000000000000000000";
      zero = '0';
       one = '1';
       s1bit0 = source1[0];
       s1bit1 = source1[1];
       s1bit2 = source1[2];
       s1bit3 = source1[3];
       s1bit4 = source1[4];
       s1bit5 = source1[5];
       s1bit6 = source1[6];
       s1bit7 = source1[7];
       s1bit8 = source1[8];
       s1bit9 = source1[9];
       s1bit10 = source1[10];
       s1bit11 = source1[11];
       s1bit12 = source1[12];
       s1bit13 = source1[13];
       s1bit14 = source1[14];
       s1bit15 = source1[15];
       s1bit16 = source1[16];
       s1bit17 = source1[17];
       s1bit18 = source1[18];
       s1bit19 = source1[19];
       s1bit20 = source1[20];
       s1bit21 = source1[21];
       s1bit22 = source1[22];
       s1bit23 = source1[23];
       s1bit24 = source1[24];
       s1bit25 = source1[25];
       s1bit26 = source1[26];
       s1bit27 = source1[27];
       s1bit28 = source1[28];
       s1bit29 = source1[29];
       s1bit30 = source1[30];
       s1bit31 = source1[31];
      
      
      //CREATION OF THE SHIFTED VALUES TO ADD LATER
      shifted3 = <zero, zero, zero, s1bit31, s1bit30, s1bit29, s1bit28, s1bit27, s1bit26, s1bit25, s1bit24, s1bit23, s1bit22, s1bit21, s1bit20, s1bit19, s1bit18, s1bit17, s1bit16, s1bit15, s1bit14, s1bit13, s1bit12, s1bit11, s1bit10, s1bit9, s1bit8, s1bit7, s1bit6, s1bit5, s1bit4, s1bit3>;
      shifted2 = <zero, zero, s1bit31, s1bit30, s1bit29, s1bit28, s1bit27, s1bit26, s1bit25, s1bit24, s1bit23, s1bit22, s1bit21, s1bit20, s1bit19, s1bit18, s1bit17, s1bit16, s1bit15, s1bit14, s1bit13, s1bit12, s1bit11, s1bit10, s1bit9, s1bit8, s1bit7, s1bit6, s1bit5, s1bit4, s1bit3, s1bit2>;
      shifted1 = <zero, s1bit31, s1bit30, s1bit29, s1bit28, s1bit27, s1bit26, s1bit25, s1bit24, s1bit23, s1bit22, s1bit21, s1bit20, s1bit19, s1bit18, s1bit17, s1bit16, s1bit15, s1bit14, s1bit13, s1bit12, s1bit11, s1bit10, s1bit9, s1bit8, s1bit7, s1bit6, s1bit5, s1bit4, s1bit3, s1bit2, s1bit1>;
      shifted0 = <s1bit31, s1bit30, s1bit29, s1bit28, s1bit27, s1bit26, s1bit25, s1bit24, s1bit23, s1bit22, s1bit21, s1bit20, s1bit19, s1bit18, s1bit17, s1bit16, s1bit15, s1bit14, s1bit13, s1bit12, s1bit11, s1bit10, s1bit9, s1bit8, s1bit7, s1bit6, s1bit5, s1bit4, s1bit3, s1bit2, s1bit1, s1bit0>;
      
      //STEP 1
      
      
      
      
      
      
      
      
      
      
      
      
      //WE ASSIGN THE INITIAL VALUE (>>3)
      initial_value = shifted3;
      
      
      //STEP 2
      
      
      
      
      
      
      
      
      
      
      
      
      // WE CHECK IF THE REQUESTED BITS ARE ON
      check4 = source2[2];
      check2 = source2[1];
      check1 = source2[0];
      
      //STEP3
      
      
      
      
      
      
      
      
      
      
      
      
      
      //IF NOT ON THE SHIFTED VALUE BECOMES 0
      checkedvalue4 = (check4) ? shifted0 : ZERO;
      checkedvalue2 = (check2) ? shifted1 : ZERO;
      checkedvalue1 = (check1) ? shifted2 : ZERO;
      
      //STEP4
      
      
      
      
      
      
      
      
      
      
      
      
      
      // TRIPLE ADD ON THE CHECKED VALUES AND ADDED TO THE INITIAL
      triple_adder_zero = '0';
      <triple_adder_output1,triple_adder_cout1> = newADDER1.adc(checkedvalue1,checkedvalue2,triple_adder_zero);
      <triple_adder_output,triple_adder_cout2> = newADDER2.adc(triple_adder_output1,checkedvalue4,triple_adder_cout1);
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(initial_value, triple_adder_output);
      output = alu_result;
      // foward output to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, output);
      null = FWU1.forward1(rd, output);
    };

    stage 4 :
    {
      null = GPR.write0(rd, output);        // write output[arg2] to GPR[arg1]
      // foward output to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, output);
      null = FWU1.forward2(rd, output);
    };
  };
  instruction STEP4b : RR3
  {
    opecode  func = "111111";
    opecode  ope = "111101";

    wire [3:0]   alu_flag;
    wire [31:0] added;
    wire [31:0] subbed;
    
    wire [31:0] c2_source1;
    wire [31:0] c1_source1;
    wire [31:0] output;
    wire sign;
    wire zero;
    wire coutA;
    wire coutS;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  source3; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rs3; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      wire [31:0]  gpr_double_read_stmp3;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rs3 = tmp_ir[21:17]; rd = tmp_ir[16:12]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      gpr_double_read_stmp3   = GPR.read2(rs3);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
      source3  = FWU2.forward(rs3, gpr_double_read_stmp3);
    };

    stage 3 :
    {
      //<inverted_source1, alu_flag> = ALU.not(source1);
      zero = '0';
      c1_source1 = ~source1;
      <c2_source1, alu_flag> = ALU.inc(c1_source1);
      
      sign = source2[0];
      <added,coutA> = newADDER1.adc(source3,source1,zero);
      <subbed,coutS> = newADDER2.adc(source3,c2_source1,zero);
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      //IF POSITIVE SIGN SUB; OTHERWISE ADDD
      output = (sign) ? subbed : added;
      // foward output to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, output);
      null = FWU1.forward1(rd, output);
    };

    stage 4 :
    {
      null = GPR.write0(rd, output);        // write output[arg2] to GPR[arg1]
      // foward output to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, output);
      null = FWU1.forward2(rd, output);
    };
  };
}
